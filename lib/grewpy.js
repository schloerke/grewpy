// Generated by CoffeeScript 1.3.1
var EventEmitter, type_of, worker_args_to_status,
  __slice = [].slice;

type_of = null;

(function() {
  var array_ctor, date_ctor, regex_ctor;
  array_ctor = (new Array).constructor;
  date_ctor = (new Date).constructor;
  regex_ctor = (new RegExp).constructor;
  return type_of = function(v) {
    if (typeof v === 'object') {
      if (v === null) {
        return 'null';
      }
      if (v.constructor === array_ctor) {
        return 'array';
      }
      if (v.constructor === date_ctor) {
        return 'date';
      }
      return 'object';
    } else {
      if ((v != null ? v.constructor : void 0) === regex_ctor) {
        return 'regex';
      }
      return typeof v;
    }
  };
})();

EventEmitter = require('events').EventEmitter;

worker_args_to_status = function(args) {
  var cb, events, firstItem, fns, isClosed, results, secItem, set_arg_to_value, thirdItem, workerCount, wrong_format;
  wrong_format = function() {
    throw "'worker()' must be called with the following format: grewpy.worker([workerCount], [arrayOfFns], [callback])";
  };
  cb = null;
  fns = [];
  isClosed = false;
  workerCount = -1;
  events = new EventEmitter();
  set_arg_to_value = function(arg) {
    switch (type_of(arg)) {
      case "array":
        fns = arg;
        break;
      case "function":
        cb = arg;
        break;
      case "number":
        workerCount = arg;
        break;
      default:
        wrong_format();
    }
  };
  switch (args.length) {
    case 0:
      isClosed = false;
      break;
    case 1:
      isClosed = false;
      firstItem = args[0];
      set_arg_to_value(firstItem);
      break;
    case 2:
      firstItem = args[0];
      secItem = args[1];
      if (type_of(firstItem) === type_of(secItem)) {
        throw "arguments 0 and 1 have the same type: " + (type_of(firstItem));
      }
      set_arg_to_value(firstItem);
      set_arg_to_value(secItem);
      break;
    case 3:
      firstItem = args[0];
      secItem = args[1];
      thirdItem = args[2];
      if (type_of(firstItem) === type_of(secItem)) {
        throw "arguments 0 and 1 have the same type: " + (type_of(firstItem));
      }
      if (type_of(firstItem) === type_of(thirdItem)) {
        throw "arguments 1 and 2 have the same type: " + (type_of(secItem));
      }
      if (type_of(secItem) === type_of(thirdItem)) {
        throw "arguments 2 and 3 have the same type: " + (type_of(secItem));
      }
      set_arg_to_value(firstItem);
      set_arg_to_value(secItem);
      set_arg_to_value(thirdItem);
      break;
    default:
      wrong_format();
  }
  isClosed = (cb != null) && (fns.length > 0);
  results = [];
  return {
    cb: cb,
    fns: fns,
    results: results,
    events: events,
    workerCount: workerCount,
    foundError: null,
    isClosed: isClosed,
    startedCount: 0,
    storedCount: 0,
    can_add_worker: function() {
      if (this.startedCount === this.fns.length) {
        return false;
      }
      if (workerCount < 0) {
        return true;
      }
      return (this.startedCount - this.storedCount) < this.workerCount;
    },
    store: function(item, pos) {
      this.storedCount++;
      this.results[pos] = item;
    },
    has_more: function() {
      return this.storedCount < this.fns.length;
    },
    is_finished: function() {
      return (this.storedCount === this.fns.length) && this.isClosed;
    },
    call_cb: function() {
      if (typeof this.cb === "function") {
        this.cb(this.foundError, this.results);
      }
    },
    call_or_set_error: function(e) {
      if (this.cb) {
        if (this.foundError == null) {
          this.foundError = e;
        }
        this.cb(e, this.results);
      } else {
        this.foundError = e;
      }
    }
  };
};

exports.worker = function() {
  var args, call_fn, events, fn, fnPos, status, _i, _len, _ref;
  args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
  status = worker_args_to_status(args);
  events = status.events;
  if (status.isClosed && status.fns.length === 0) {
    status.call_cb();
    return {
      status: status,
      events: events
    };
  }
  call_fn = function(fnPos, fn) {
    var done;
    if (status.foundError) {
      return;
    }
    events.emit("worker_started", fnPos);
    done = function(err, result) {
      events.emit("worker_finished", fnPos, err, result);
    };
    try {
      fn(done);
    } catch (err) {
      events.emit("worker_finished", fnPos, err, null);
    }
  };
  events.on("worker_started", function(pos) {
    status.startedCount++;
  });
  events.on("worker_finished", function(pos, err, result) {
    if (status.foundError) {
      return;
    }
    if (err != null) {
      status.call_or_set_error(err);
      return;
    }
    status.store(result, pos);
    if (status.is_finished()) {
      status.call_cb();
    } else if (status.can_add_worker()) {
      call_fn(status.startedCount, status.fns[status.startedCount]);
    }
  });
  _ref = status.fns;
  for (fnPos = _i = 0, _len = _ref.length; _i < _len; fnPos = ++_i) {
    fn = _ref[fnPos];
    if (status.can_add_worker()) {
      events.emit("fn_added", fnPos);
      call_fn(fnPos, fn);
    } else {
      break;
    }
  }
  return {
    status: status,
    events: events,
    add: function(fn) {
      var fnsLen;
      if (status.isClosed) {
        return;
      }
      fnsLen = status.fns.push(fn);
      fnPos = fnsLen - 1;
      if (status.can_add_worker()) {
        events.emit("fn_added", fnPos);
        call_fn(fnPos, fn);
      } else {
        events.emit("fn_queued", fnPos);
      }
    },
    finalize: function(cb) {
      status.isClosed = true;
      if (cb) {
        if (type_of(cb) !== "function") {
          throw "callback supplied is not a function";
        }
        status.cb = cb;
        if (status.foundError) {
          status.call_cb();
          return;
        }
      }
      if (type_of(status.cb) !== "function") {
        throw "no callback fuction to execute";
      }
      if (status.is_finished()) {
        status.call_cb();
        return;
      }
    }
  };
};

exports.group = function() {
  var args;
  args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
  args.push(-1);
  return exports.worker.apply(null, args);
};

exports.chain = function() {
  var args;
  args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
  args.push(1);
  return exports.worker.apply(null, args);
};
