// Generated by CoffeeScript 1.3.1
var add_test, expectedTime, formationState, grewpy, method, timeout, valueArr, values, valuesTitle, workerCount, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;

grewpy = require('../../');

add_test = function(_arg) {
  var calls, expectedTime, fn, fnArr, formationState, method, methodTitle, timeout, value, values, valuesTitle, workerCount, _i, _len;
  method = _arg.method, values = _arg.values, expectedTime = _arg.expectedTime, valuesTitle = _arg.valuesTitle, timeout = _arg.timeout, formationState = _arg.formationState, workerCount = _arg.workerCount;
  formationState || (formationState = 0);
  if (grewpy[method] == null) {
    throw "method not supported!";
  }
  if (timeout == null) {
    timeout = null;
  }
  methodTitle = [method, valuesTitle, timeout != null ? timeout : "null", workerCount != null ? workerCount : "null", "(" + formationState + ")"].join("_");
  fn = null;
  calls = 0;
  fn = function(value) {
    return function(done) {
      var inner_fn;
      inner_fn = function() {
        calls++;
        done(null, value);
      };
      if (timeout != null) {
        setTimeout(inner_fn, timeout);
      } else {
        inner_fn();
      }
    };
  };
  fnArr = [];
  for (_i = 0, _len = values.length; _i < _len; _i++) {
    value = values[_i];
    fnArr.push(fn(value));
  }
  exports[methodTitle] = function(test) {
    var afterArr, beforeArr, cb, fn, info, splitPos, startTime, _j, _k, _l, _len1, _len2, _len3, _len4, _len5, _len6, _len7, _len8, _m, _n, _o, _p, _q;
    test.expect(5 + values.length);
    startTime = new Date();
    cb = function(err, results) {
      var endTime, result, resultPos, timeDiff, timeIsOk, _j, _len1;
      endTime = new Date();
      timeDiff = endTime.valueOf() - startTime.valueOf();
      timeIsOk = false;
      if (timeout) {
        if (((expectedTime * timeout) - (timeout / 2)) < timeDiff) {
          if (((expectedTime * timeout) + (timeout + 0 / 2)) > timeDiff) {
            timeIsOk = true;
          }
        }
      } else {
        timeIsOk = timeDiff < 5;
      }
      test.ok(timeIsOk, "finished in the proper amount of time");
      test.equals(err, null, "error isnt null");
      test.equals(calls, values.length, "finished the same amount of values");
      test.ok(Array.isArray(results), "results are an array");
      test.equals(results.length, values.length, "results are same length as values");
      for (resultPos = _j = 0, _len1 = results.length; _j < _len1; resultPos = ++_j) {
        result = results[resultPos];
        test.equals(result, values[resultPos], "result is same result at pos: " + resultPos);
      }
      test.done();
    };
    switch (formationState) {
      case "cb_start,fn_start":
        return grewpy[method](fnArr, cb);
      case "cb_end,fn_start":
        info = grewpy[method](fnArr);
        return info.finalize(cb);
      case "cb_start,fn_add":
        info = grewpy[method](cb);
        for (_j = 0, _len1 = fnArr.length; _j < _len1; _j++) {
          fn = fnArr[_j];
          info.add(fn);
        }
        return info.finalize();
      case "cb_end,fn_add":
        info = grewpy[method]();
        for (_k = 0, _len2 = fnArr.length; _k < _len2; _k++) {
          fn = fnArr[_k];
          info.add(fn);
        }
        return info.finalize(cb);
      case "cb_end,fn_split":
        splitPos = Math.floor(fnArr.length / 2);
        beforeArr = fnArr.slice(0, splitPos);
        afterArr = fnArr.slice(splitPos);
        info = grewpy[method](beforeArr);
        for (_l = 0, _len3 = afterArr.length; _l < _len3; _l++) {
          fn = afterArr[_l];
          info.add(fn);
        }
        return info.finalize(cb);
      case "cb_start,fn_start,workerA":
        return grewpy[method](workerCount, fnArr, cb);
      case "cb_start,fn_start,workerB":
        return grewpy[method](workerCount, cb, fnArr);
      case "cb_start,fn_start,workerC":
        return grewpy[method](fnArr, workerCount, cb);
      case "cb_start,fn_start,workerD":
        return grewpy[method](fnArr, cb, workerCount);
      case "cb_start,fn_start,workerE":
        return grewpy[method](cb, fnArr, workerCount);
      case "cb_start,fn_start,workerF":
        return grewpy[method](cb, workerCount, fnArr);
      case "cb_end,fn_start,workerA":
        info = grewpy[method](workerCount, fnArr);
        return info.finalize(cb);
      case "cb_end,fn_start,workerB":
        info = grewpy[method](fnArr, workerCount);
        return info.finalize(cb);
      case "cb_start,fn_add,workerA":
        info = grewpy[method](workerCount, cb);
        for (_m = 0, _len4 = fnArr.length; _m < _len4; _m++) {
          fn = fnArr[_m];
          info.add(fn);
        }
        return info.finalize();
      case "cb_start,fn_add,workerB":
        info = grewpy[method](cb, workerCount);
        for (_n = 0, _len5 = fnArr.length; _n < _len5; _n++) {
          fn = fnArr[_n];
          info.add(fn);
        }
        return info.finalize();
      case "cb_end,fn_add,workerA":
        info = grewpy[method](workerCount);
        for (_o = 0, _len6 = fnArr.length; _o < _len6; _o++) {
          fn = fnArr[_o];
          info.add(fn);
        }
        return info.finalize(cb);
      case "cb_end,fn_split,workerA":
        splitPos = Math.floor(fnArr.length / 2);
        beforeArr = fnArr.slice(0, splitPos);
        afterArr = fnArr.slice(splitPos);
        info = grewpy[method](workerCount, beforeArr);
        for (_p = 0, _len7 = afterArr.length; _p < _len7; _p++) {
          fn = afterArr[_p];
          info.add(fn);
        }
        return info.finalize(cb);
      case "cb_end,fn_split,workerB":
        splitPos = Math.floor(fnArr.length / 2);
        beforeArr = fnArr.slice(0, splitPos);
        afterArr = fnArr.slice(splitPos);
        info = grewpy[method](beforeArr, workerCount);
        for (_q = 0, _len8 = afterArr.length; _q < _len8; _q++) {
          fn = afterArr[_q];
          info.add(fn);
        }
        return info.finalize(cb);
      default:
        throw "formationState " + formationState + " not valid";
    }
  };
};

valueArr = [[[void 0, void 0, void 0, void 0], "undefined"], [[null, null, null, null], "null"], [["red", "green", "blue", "yellow"], "colors"], [["red", void 0, null, "yellow"], "mixedColors"]];

_ref = [null, 50];
for (_i = 0, _len = _ref.length; _i < _len; _i++) {
  timeout = _ref[_i];
  for (_j = 0, _len1 = valueArr.length; _j < _len1; _j++) {
    _ref1 = valueArr[_j], values = _ref1[0], valuesTitle = _ref1[1];
    _ref2 = [["chain", values.length, 1], ["group", 1, values.length]];
    for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
      _ref3 = _ref2[_k], method = _ref3[0], expectedTime = _ref3[1], workerCount = _ref3[2];
      _ref4 = ["cb_start,fn_start", "cb_start,fn_add", "cb_end,fn_start", "cb_end,fn_add", "cb_end,fn_split"];
      for (_l = 0, _len3 = _ref4.length; _l < _len3; _l++) {
        formationState = _ref4[_l];
        add_test({
          method: method,
          values: values,
          valuesTitle: valuesTitle,
          expectedTime: expectedTime,
          timeout: timeout,
          formationState: formationState,
          workerCount: workerCount
        });
      }
    }
    _ref5 = [["worker", values.length / 1, 1], ["worker", values.length / 2, 2], ["worker", values.length / 4, 4]];
    for (_m = 0, _len4 = _ref5.length; _m < _len4; _m++) {
      _ref6 = _ref5[_m], method = _ref6[0], expectedTime = _ref6[1], workerCount = _ref6[2];
      _ref7 = ["cb_start,fn_start,workerA", "cb_start,fn_start,workerB", "cb_start,fn_start,workerC", "cb_start,fn_start,workerD", "cb_start,fn_start,workerE", "cb_start,fn_start,workerF", "cb_end,fn_start,workerA", "cb_end,fn_start,workerB", "cb_start,fn_add,workerA", "cb_start,fn_add,workerB", "cb_end,fn_add,workerA", "cb_end,fn_split,workerA", "cb_end,fn_split,workerB"];
      for (_n = 0, _len5 = _ref7.length; _n < _len5; _n++) {
        formationState = _ref7[_n];
        add_test({
          method: method,
          values: values,
          valuesTitle: valuesTitle,
          expectedTime: expectedTime,
          timeout: timeout,
          formationState: formationState,
          workerCount: workerCount
        });
      }
    }
  }
}
