// Generated by CoffeeScript 1.3.1
var add_test, expectedTime, formationState, grewpy, method, timeout, valueArr, values, valuesTitle, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3, _ref4,
  __slice = [].slice;

grewpy = require('../../');

add_test = function(_arg) {
  var calls, expectedTime, fn, fnArr, formationState, method, methodTitle, timeout, value, values, valuesTitle, _i, _len;
  method = _arg.method, values = _arg.values, expectedTime = _arg.expectedTime, valuesTitle = _arg.valuesTitle, timeout = _arg.timeout, formationState = _arg.formationState;
  formationState || (formationState = 0);
  if (grewpy[method] == null) {
    throw "method not supported!";
  }
  if (timeout == null) {
    timeout = null;
  }
  methodTitle = [method, valuesTitle, timeout != null ? timeout : "null", "(" + formationState + ")"].join("_");
  fn = null;
  calls = 0;
  fn = function(value) {
    return function(done) {
      var inner_fn;
      inner_fn = function() {
        calls++;
        done(null, value);
      };
      if (timeout != null) {
        setTimeout(inner_fn, timeout);
      } else {
        inner_fn();
      }
    };
  };
  fnArr = [];
  for (_i = 0, _len = values.length; _i < _len; _i++) {
    value = values[_i];
    fnArr.push(fn(value));
  }
  exports[methodTitle] = function(test) {
    var afterArr, beforeArr, cb, fn, info, splitPos, startTime, _j, _k, _l, _len1, _len2, _len3;
    test.expect(5 + values.length);
    startTime = new Date();
    cb = function(err, results) {
      var endTime, result, resultPos, timeDiff, timeIsOk, _j, _len1;
      endTime = new Date();
      timeDiff = endTime.valueOf() - startTime.valueOf();
      timeIsOk = false;
      if (timeout) {
        if (((expectedTime * timeout) - (timeout / 2)) < timeDiff) {
          if (((expectedTime * timeout) + (timeout + 0 / 2)) > timeDiff) {
            timeIsOk = true;
          }
        }
      } else {
        timeIsOk = timeDiff < 5;
      }
      test.ok(timeIsOk, "finished in the proper amount of time");
      test.equals(err, null, "error isnt null");
      test.equals(calls, values.length, "finished the same amount of values");
      test.ok(Array.isArray(results), "results are an array");
      test.equals(results.length, values.length, "results are same length as values");
      for (resultPos = _j = 0, _len1 = results.length; _j < _len1; resultPos = ++_j) {
        result = results[resultPos];
        test.equals(result, values[resultPos], "result is same result at pos: " + resultPos);
      }
      test.done();
    };
    switch (formationState) {
      case "cb_start,fn_start":
        return grewpy[method](fnArr, cb);
      case "cb_end,fn_start":
        info = grewpy[method](fnArr);
        return info.finalize(cb);
      case "cb_start,fn_add":
        info = grewpy[method](cb);
        for (_j = 0, _len1 = fnArr.length; _j < _len1; _j++) {
          fn = fnArr[_j];
          info.add(fn);
        }
        return info.finalize();
      case "cb_end,fn_add":
        info = grewpy[method]();
        if (info.events && false) {
          console.log("info: ", info);
          info.events.on("fn_added", function(pos) {
            console.log("fn_added at pos: ", pos);
          });
          info.events.on("worker_started", function(pos) {
            console.log("worker_started at pos: ", pos);
          });
          info.events.on("worker_finished", function(pos, err, result) {
            console.log("worker_finished at pos: ", pos, " err: ", err, " result: ", result);
          });
          info.events.on("fn_queued", function(pos) {
            console.log("fn_queued at pos: ", pos);
          });
        }
        for (_k = 0, _len2 = fnArr.length; _k < _len2; _k++) {
          fn = fnArr[_k];
          info.add(fn);
        }
        return info.finalize(cb);
      case "cb_end,fn_split":
        splitPos = Math.floor(fnArr.length / 2);
        beforeArr = fnArr.slice(0, splitPos);
        afterArr = fnArr.slice(splitPos);
        info = grewpy[method](beforeArr);
        for (_l = 0, _len3 = afterArr.length; _l < _len3; _l++) {
          fn = afterArr[_l];
          info.add(fn);
        }
        return info.finalize(cb);
      default:
        throw "formationState " + formationState + " not valid";
    }
  };
};

valueArr = [[[void 0, void 0, void 0, void 0], "undefined"], [[null, null, null, null], "null"], [["red", "green", "blue", "yellow"], "colors"], [["red", void 0, null, "yellow"], "mixedColors"]];

grewpy.two_worker = function() {
  var args;
  args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
  args.push(2);
  return grewpy.worker.apply(null, args);
};

_ref = [null, 50];
for (_i = 0, _len = _ref.length; _i < _len; _i++) {
  timeout = _ref[_i];
  for (_j = 0, _len1 = valueArr.length; _j < _len1; _j++) {
    _ref1 = valueArr[_j], values = _ref1[0], valuesTitle = _ref1[1];
    _ref2 = [["chain", values.length], ["group", 1], ["two_worker", values.length / 2]];
    for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
      _ref3 = _ref2[_k], method = _ref3[0], expectedTime = _ref3[1];
      _ref4 = ["cb_start,fn_start", "cb_start,fn_add", "cb_end,fn_start", "cb_end,fn_add", "cb_end,fn_split"];
      for (_l = 0, _len3 = _ref4.length; _l < _len3; _l++) {
        formationState = _ref4[_l];
        add_test({
          method: method,
          values: values,
          valuesTitle: valuesTitle,
          expectedTime: expectedTime,
          timeout: timeout,
          formationState: formationState
        });
      }
    }
  }
}
